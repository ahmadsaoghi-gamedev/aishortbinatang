import { GoogleGenAI, Modality } from "@google/genai";

if (!process.env.API_KEY) {
    throw new Error("The API_KEY environment variable is not set. Please ensure it is configured.");
}

const ai = new GoogleGenAI({ apiKey: process.env.API_KEY });

const handleGeminiError = (error: unknown, context: 'generation' | 'editing'): Error => {
    console.error(`Error during image ${context}:`, error);

    if (error instanceof Error && error.message) {
        try {
            // The error message from the SDK can be a JSON string.
            const errorData = JSON.parse(error.message);
            if (errorData?.error?.status === 'RESOURCE_EXHAUSTED') {
                let detail = errorData.error.message || "Please check your plan and billing details.";
                if (detail.includes("limit: 0")) {
                    detail = "Your project's quota for this model is 0, which prevents any requests. This is usually because billing is not enabled for your Google Cloud project. Please visit your project's billing page to enable it and ensure the Generative Language API is configured correctly.";
                }
                return new Error(`API Quota Exceeded. ${detail}`);
            }
             // If it's a JSON but not a quota error, stringify it for clarity
             return new Error(`Gemini API Error: ${JSON.stringify(errorData.error)}`);
        } catch (e) {
            // Not a JSON error message, just return the original message.
            return new Error(`Gemini API Error: ${error.message}`);
        }
    }
    return new Error(`An unknown error occurred during image ${context}.`);
};

/**
 * Generates an image using Pollinations.ai as a fallback service.
 * @param prompt The text prompt to generate the image from.
 * @param aspectRatio The desired aspect ratio (e.g., '9:16').
 * @returns A promise that resolves to a base64 data URL of the generated image.
 */
const generateImageWithPollinations = async (prompt: string, aspectRatio: string): Promise<string> => {
    const aspectRatios: { [key: string]: { width: number, height: number } } = {
        '9:16': { width: 576, height: 1024 },
        '16:9': { width: 1024, height: 576 },
        '1:1': { width: 1024, height: 1024 },
        '4:3': { width: 1024, height: 768 },
        '3:4': { width: 768, height: 1024 },
    };

    const dimensions = aspectRatios[aspectRatio] || { width: 1024, height: 1024 };

    const encodedPrompt = encodeURIComponent(prompt);
    const seed = Math.floor(Math.random() * 100000);
    const url = `https://image.pollinations.ai/prompt/${encodedPrompt}?width=${dimensions.width}&height=${dimensions.height}&seed=${seed}`;

    const response = await fetch(url);
    if (!response.ok) {
        throw new Error(`Pollinations.ai request failed with status ${response.status}`);
    }

    const blob = await response.blob();
    
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onloadend = () => resolve(reader.result as string);
        reader.onerror = reject;
        reader.readAsDataURL(blob);
    });
};


/**
 * Generates an image using the Gemini API, with a fallback to Pollinations.ai.
 * @param prompt The text prompt to generate the image from.
 * @param aspectRatio The desired aspect ratio string (e.g., '9:16').
 * @returns A promise that resolves to a base64 data URL of the generated image.
 */
export const generateImage = async (prompt: string, aspectRatio: string): Promise<string> => {
    try {
        // Add the aspect ratio to the prompt, which might help guide the model, even if not strictly enforced.
        const enhancedPrompt = `${prompt}. The image must be in a ${aspectRatio} aspect ratio.`;
        
        const response = await ai.models.generateContent({
            model: 'gemini-2.5-flash-image-preview',
            contents: {
                parts: [
                    {
                        text: enhancedPrompt,
                    },
                ],
            },
            config: {
                responseModalities: [Modality.IMAGE, Modality.TEXT],
            },
        });

        for (const part of response.candidates[0].content.parts) {
            if (part.inlineData && part.inlineData.mimeType.startsWith('image/')) {
                const base64ImageBytes = part.inlineData.data;
                const newMimeType = part.inlineData.mimeType;
                return `data:${newMimeType};base64,${base64ImageBytes}`;
            }
        }
        
        throw new Error("No image was generated by the Gemini API.");
    } catch (error) {
       console.warn("Gemini image generation failed. Attempting fallback to Pollinations.ai.", error);
       try {
           const fallbackUrl = await generateImageWithPollinations(prompt, aspectRatio);
           return fallbackUrl;
       } catch (fallbackError) {
           console.error("Pollinations.ai fallback also failed:", fallbackError);
           // If the fallback also fails, throw the original, more informative Gemini error.
           throw handleGeminiError(error, 'generation');
       }
    }
};

/**
 * Edits an image using the Gemini API based on a base image and a text prompt.
 * @param base64ImageData The base64 encoded string of the image to edit.
 * @param mimeType The MIME type of the image.
 * @param prompt The text prompt describing the desired edits.
 * @returns A promise that resolves to a base64 data URL of the edited image.
 */
export const editImage = async (base64ImageData: string, mimeType: string, prompt: string): Promise<string> => {
    try {
        const response = await ai.models.generateContent({
            model: 'gemini-2.5-flash-image-preview',
            contents: {
                parts: [
                    {
                        inlineData: {
                            data: base64ImageData,
                            mimeType: mimeType,
                        },
                    },
                    {
                        text: prompt,
                    },
                ],
            },
            config: {
                responseModalities: [Modality.IMAGE, Modality.TEXT],
            },
        });

        // The response can contain multiple parts, we need to find the image part.
        for (const part of response.candidates[0].content.parts) {
            if (part.inlineData && part.inlineData.mimeType.startsWith('image/')) {
                const base64ImageBytes = part.inlineData.data;
                const newMimeType = part.inlineData.mimeType;
                return `data:${newMimeType};base64,${base64ImageBytes}`;
            }
        }
        
        throw new Error("No image was returned by the API in the edit response.");

    } catch (error) {
        throw handleGeminiError(error, 'editing');
    }
};